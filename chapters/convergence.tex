\chapter{Convergence Proofs}

\begin{algorithm}[p]
  \SetKwInOut{Input}{Input}
  \Input{\(\mat{A} \in \R^{m \times n}\), \(\vek{b} \in \R^m\), \(\vek{c} \in \R^n\), \(\gamma \in (0, 1)\), \(\sigma \in (0, \frac{4}{5})\), tolerance \(\e_\mu > 0\) and an intial point \((\vek{x}^0, \vek{y}^0, \vek{s}^0)\)}
  Initialize \(k = 0\) and \(\mu^0 = (\vek{x}^0)^T \vek{s}^0 /n\)\;
  \While{\(\mu^k = (\vek{x}^k)^T \vek{s}^k /n > \e_\mu \mu^0\)}{
    Compute \(\vek{r}_p^k = \mat{A}\vek{x}^k - \vek{b}\), \(\vek{r}_d^k = \mat{A}^T \vek{y}^k + \vek{s}^k - \vek{c}\), \(\mat{X} = \diag(\vek{x}^k)\), \(\mat{S} = \diag(\vek{s}^k)\)\;
    Solve the following linear system such that \(\norm{\vek{v}}_\infty \leq  \gamma \sigma \mu^k/4\)
    \begin{equation} \label{eqn:approx-newton}
      \begin{pmatrix}
        \mat{A} & 0         & 0       \\
        0       & \mat{A}^T & \mat{I} \\
        \mat{S} & 0         & \mat{X} \\
      \end{pmatrix}
      \begin{pmatrix} \Delta\hat{\vek{x}} \\ \Delta\hat{\vek{y}} \\ \Delta\hat{\vek{s}} \end{pmatrix}
      =
      \begin{pmatrix} -\vek{r}_p^k \\ -\vek{r}_d^k \\ -\vek{x}^k \circ \vek{s}^k + \sigma \mu^k \vek{1} \end{pmatrix}
      -
      \begin{pmatrix} 0 \\ 0 \\ \vek{v} \end{pmatrix} \text{\;}
    \end{equation} \\ \label{line:compute-approx-newton}
    Determine the maximum \(\tilde{\alpha} \in [0, 1]\) such that for all \(\alpha \in [0, \tilde{\alpha}]\) we have \((\vek{x}^k, \vek{y}^k, \vek{s}^k) + \alpha (\Delta\hat{\vek{x}}, \Delta\hat{\vek{y}}, \Delta{\hat{\vek{s}}}) \in \mathcal{N}(\gamma)\)\;
    Compute \(\bar{\alpha} = \argmin \set{ (\vek{x}^k + \alpha \Delta\hat{\vek{x}})^T (\vek{s}^k + \alpha \Delta{\hat{\vek{s}}}) | \alpha \in [0, \tilde{\alpha}]}\)\;
    Set \((\vek{x}^{k+1}, \vek{y}^{k+1}, \vek{s}^{k+1}) = (\vek{x}^k, \vek{y}^k, \vek{s}^k) + \bar{\alpha} (\Delta\hat{\vek{x}}, \Delta\hat{\vek{y}}, \Delta{\hat{\vek{s}}}) \)\;
    Increment \(k \leftarrow k+1\)\;
  }
  \Return{\((\vek{x}^k, \vek{y}^k, \vek{s}^k)\)}\;
  \caption{Infeasible IPM} \label{alg:ipm}
\end{algorithm}

\begin{algorithm}[p]
  \SetKwInOut{Input}{Input}
  \Input{\(\mat{A} \in \R^{m \times n}\), \(\vek{b} \in \R^m\), \(\vek{c} \in \R^n\), \(\vek{x}, \vek{s} \in \R^n_{>0}\), \(\vek{y} \in \R^m\), tolerance \(\e_{\vek{v}} > 0\), failure probability \(\delta > 0\)}
  Compute \(\vek{r}_p = \mat{A}\vek{x} - \vek{b}\), \(\vek{r}_d = \mat{A}^T \vek{y} + \vek{s} - \vek{c}\), \(\mat{X} = \diag(\vek{x})\), \(\mat{S} = \diag(\vek{s})\)\;
  Compute \(\vek{p} = -\vek{r}_p + \mat{A}(-\mat{S}^{-1}\mat{X}\vek{r}_d + \vek{x} - \sigma \mu \mat{S}^{-1} \vek{1})\)\;
  Construct a random sparse embedding matrix \(\mat{W} \in \R^{w \times m}\) as in \cref{eqn:sparse-ose-params} for the given \(\delta\)\;
  Compute the QR decomposition \(\mat{Q} \mat{R} = \mat{W} \mat{D} \mat{A}^T\)\;
  Run the CG algorithm with \(\vek{q}^0 = \vek{0}\) until \(\mat{R}^{-T} \mat{A} \mat{D}^2 \mat{A}^T \mat{R}^{-1} \vek{q} = \mat{R}^{-T} \vek{p} + \vek{f}\) for some error \(\vek{f}\) satisfying \(\norm{\vek{f}}_2 \leq \e_{\vek{v}}/(n \sqrt{\mu})\)\; \label{line:cg}
  Compute \(\vek{v} = (\mat{S} \mat{X})^{1/2} \mat{W}^T \mat{Q} \vek{f}\)\; \label{line:compute-v}
  Compute \(\Delta\vek{y} = \mat{R}^{-1}\vek{q}\)\;
  Compute \(\Delta\vek{s} = -\vek{r}_d - \mat{A}^T \Delta\vek{y}\)\;
  Compute \(\Delta\vek{x} = -\vek{x} + \sigma \mu \vek{1} - \mat{S}^{-1}\mat{X} \Delta\vek{s} - \mat{S}^{-1} \vek{v}\)\; \label{line:compute-delta-x}
  \Return{\((\Delta\vek{x}, \Delta\vek{y}, \Delta\vek{s})\)}\;
  \caption{Approximate Newton direction} \label{alg:newton-direction}
\end{algorithm}

To give any convergence proofs it is necessary to exactly state the algorithm.
\Cref{alg:ipm} is the same infeasible inexact long-step interior-point method as in \cite{Avron-FasterRandomizedInfeasibleIPMs,Monteiro-ConvergenceAnalysisLongStepInfeasibleIPMs} but with a different preconditioner.
To keep the convergence proof of the IPM seperate from the considerations on how to solve for an approximate Newton direction we will consider the computation of the Newton direction in \cref{alg:newton-direction}.

The first part of this chapter will be concerned with the convergence of \cref{alg:ipm} and its runtime.
The main result is
\begin{theorem}
Assume that \(\gamma \in (0, 1)\) and \(\sigma \in (0, \frac{4}{5})\) are constant and that the initial point \((\vek{x}^0, \vek{y}^0, \vek{s}^0)\) satisfies \((\vek{x}^0, \vek{s}^0) > (\vek{x}^*, \vek{s}^*)\) for some \((\vek{x}^*, \vek{y}^*, \vek{s}^*) \in \mathcal{F}^*\).
Then \cref{alg:ipm} generates an iterate \((\vek{x}^k, \vek{y}^k, \vek{s}^k)\) satisfying \(\mu^k \leq \e_\mu \mu^0\) and \(\norm{\vek{r}^k} \leq \e_\mu \norm{\vek{r}^0}\) within \(O(n^2 \log(1/\e_\mu))\) iterations.
\end{theorem}
%TODO Change notation: \bar -> * and S to F*?

\Cref{line:compute-approx-newton} of \cref{alg:ipm} is written as a black box generating a sufficiently good estimate of the Newton direction at every step.
To complete the algorithm we need to show that this gap can be filled using \cref{alg:newton-direction} which uses the previously designed preconditioner and perturbation vector to compute such an approximation:
\begin{theorem}
Assume that \(\gamma \in (0, 1)\) and \(\sigma \in (0, 1)\) are constant. \cref{alg:newton-direction} computes an approximation of the Newton direction that satisfies \cref{eqn:approx-newton} with \(\norm{v}_2 \leq \e_{\vek{v}}\) with probability at least \(1 - \delta\).
Moreover, for \(\e_{\vek{v}} = \gamma \sigma \mu / 4\) the CG algorithm only needs \(O(\log(n))\) inner iterations and the whole algorithm needs \(O(???)\) flops.
\end{theorem}

These two theorems can be combined to obtain the convergence of our method and its runtime guarantees:
\begin{theorem}
Assume that \(\gamma \in (0, 1)\) and \(\sigma \in (0, \frac{4}{5})\) are constant and that the initial point \((\vek{x}^0, \vek{y}^0, \vek{s}^0)\) satisfies \((\vek{x}^0, \vek{s}^0) > (\vek{x}^*, \vek{s}^*)\) for some \((\vek{x}^*, \vek{y}^*, \vek{s}^*) \in \mathcal{F}^*\).
Furthermore, assume that \cref{alg:ipm} uses \cref{alg:newton-direction} with \(\e_{\vek{v}} = \gamma \sigma \mu^k / 4\) to determine the approximate Newton direction in every step.
Then the algorithm terminates successfully using only \(O(???)\) flops with probability at least \(99\%\) for \(\delta = O(n^{-2})\).
\end{theorem}